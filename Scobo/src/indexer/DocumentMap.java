package indexer;

import util.Configuration;
import util.Logger;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Maps document names to document ID's and generates said ID's.
 * {@code DocumentMap} can be in one of two modes:
 * <ul>
 *     <li>ADD mode - meant to be used internally by the indexer, when in ADD mode
 *     it is possible to add documents to the map and receive their ID's </li>
 *     <li>LOOKUP mode - is meant to be used externally after indexing, when LOOKUP mode
 *     it is impossible to add new documents but looking up document names by ID is available</li>
 * </ul>
 *
 * <p> The distinction between the modes is made because while indexing there is no need to be able to
 * lookup documents after adding them, hence when in ADD mode after reaching a certain threshold the
 * documents added to the map will be saved to the map file.
 * While in LOOKUP all the mappings are available in memory and thus it is possible to preform lookups
 * for any document.
 *
 * <p><em>{@code DocumentMap} is externally immutable meaning that it is immutable outside of
 * the scope of its package (indexer)</em>
 *
 * <p> Document Map file format:
 * Each line in the file represents a document ID -> document name mapping
 * each line line will look like so: [document ID]|[document name]\n
 * <ul>
 *     <li>document ID - id given to the document by the map</li>
 *     <li>document name - the name of the document</li>
 * </ul>
 *
 */
public final class DocumentMap {

    private static final String PATH = Configuration.getInstance().getIndexPath() + "docmap.txt";

    //TODO: optimize these values.
    private static final int LOADED_MAP_SIZE = 1024;
    private static final float LOAD_FACTOR = 0.75f;

    private HashMap<Integer, String> documents;
    private volatile int size;
    private BufferedWriter fileWriter;

    private enum MODE {ADD, LOOKUP}
    private MODE mode;

    private Indexer indexer;


    /**
     * Creates a {@code DocumentMap} in ADD mode.
     * This creates a <em>mutable</em> reference.
     *
     * @param indexer the indexer using this map.
     */
    protected DocumentMap(Indexer indexer) {
        this(MODE.ADD, LOADED_MAP_SIZE, LOAD_FACTOR);
        try { this.fileWriter = new BufferedWriter(new FileWriter(PATH)); }
        catch (IOException e) {
            Logger.getInstance().error(e);
        }
        this.indexer = indexer;
    }

    private DocumentMap(MODE mode, final int mapSize, final float loadFactor) {
        this.mode = mode;
        this.documents = new HashMap<>(mapSize, loadFactor);
    }

    /**
     * Adds a document to the map, giving it a unique ID.
     *
     * @param docName the name of the document
     * @return a positive integer representing the docID, -1 if the Map is in LOOKUP mode
     * and cannot accept more documents.
     */
    protected synchronized int addDocument(String docName) {
        if (mode == MODE.LOOKUP)
            return -1;

        int docID = size++;
        this.documents.put(docID, docName);

        if (size >= LOADED_MAP_SIZE * LOAD_FACTOR) {
            indexer.IOTasks.add(() -> dump(this.documents, fileWriter));
            this.documents = new HashMap<>(LOADED_MAP_SIZE, LOAD_FACTOR);
        }

        return docID;
    }

    /**
     * Gets the document name of the given document ID.
     *
     * @param docID a docID generated by this map
     * @return the document name associated with the given docID.
     */
    public Optional<String> lookup(int docID) {
        if (mode == MODE.ADD)
            return Optional.empty();

        return Optional.ofNullable(documents.get(docID));
    }

    /**
     * Loads the document map in LOOKUP mode
     * into memory and returns a reference to it.
     *
     * @return externally immutable reference to a {@code DocumentMap}
     * @throws IOException if the document map file is corrupted or not found.
     */
    public synchronized static DocumentMap loadDocumentMap() throws IOException {
        byte[] fileBytes = Files.readAllBytes(Paths.get(PATH));
        String fileString = new String(fileBytes);
        String[] lines = fileString.split("\n");
        DocumentMap res = new DocumentMap(MODE.LOOKUP, lines.length, LOAD_FACTOR);

        for (String line : lines) {
            String[] contents = line.split("\\|");
            if (contents.length != 2)
                throw new IOException("Dictionary file is corrupted.");

            int docID = Integer.parseInt(contents[0]);
            String docName = contents[1];

            res.documents.put(docID, docName);
        }

        return res;
    }

    /**
     * Appends all the new mappings added science the last dump to
     * the document map file.
     *
     * @param documents a document map to be saved to the file.
     */
    private static void dump(HashMap<Integer, String> documents, BufferedWriter writer) {
        try {
            for (Map.Entry<Integer, String> entry : documents.entrySet())
                writer.append(String.valueOf(entry.getKey()))
                        .append("|")
                        .append(entry.getValue())
                        .append("\n");
        } catch (IOException e) {
            Logger.getInstance().error(e);
        }
    }
}
